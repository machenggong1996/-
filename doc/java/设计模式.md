# 设计模式

## 1. 设计模式七大原则

1. 单一职责
2. 接口隔离
3. 依赖倒转
4. 里式替换
5. 开闭原则 ocp
6. 迪米特法则
7. 合成复用

### 1.1 单一职责原则

一个类只负责一项原则

1. 降低类的复杂度，一个类只负责一项职责
2. 提高类的可读性，可维护性
3. 降低变更引起的风险
4. 只有逻辑足够简单，才可以在代码级别违反单一原则

### 1.2 接口隔离原则

1. 一个类对另一个类的依赖建立在最小接口

### 1.3 依赖倒转原则 DIP

1. 高层次模块不应依赖低层次
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 中心思想是面向接口编程
4. 抽象的东西要稳定的多，抽象指的是接口或者抽象类，细节是实现类完成

使用构造器 set方法进行依赖传递 接口传递 spring依赖倒转使用的就是这三种

#### 1.3.1 小结

1. 低层模块尽量使用抽象类或者接口
2. 变量的声明类型尽量是接口或者抽象类，有利于扩展和优化
3. 遵循里式替换原则

### 1.4 里式替换原则 LSP

继承出现问题，如果父类修改可能会导致子类出问题

1. 子类尽量不要重写父类方法
2. 继承实际上将两个类的耦合性增强了，可以通过聚合，组合，依赖来解决问题，使用一个更基础的类

### 1.5 开闭原则 OCP

1. 一个软件实体，如类，模块，函数应该对扩展开发，修改关闭
2. 当用抽象构建框架，用实现扩展细节
3. 当软件功能发生变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现

#### 1.5.1 小结

建立抽象类，使用多态

### 1.6 迪米特法则 DP 最少知道原则

1. 一个对象应对其他对象保持最少的理解
2. 类与类关系越密切，耦合度越大
3. 对外除了提供public方法，不对外泄漏任何信息
4. 只与直接的朋友进行通信
5. 直接的朋友：每个对象都会有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象是朋友关系，成员变量，方法参数，方法返回值
6. 局部变量中的类不是直接的朋友

#### 1.6.1 细节

1. 降低耦合度

### 1.7 合成复用原则

1. 尽量使用合成和聚合的方式，而不是使用继承

## 2. UML类图

### 2.1 类与类之间的关系

依赖，泛化（继承），实现，关联，聚合，组合

#### 2.1.1 依赖

* 在类中用到了对方
* 类的成员属性
* 方法的返回类型
* 方法接收的参数类型
* 方法中使用到

虚线箭头

#### 2.1.2 泛化（继承）

实现三角形箭头

#### 2.1.3 关联关系

依赖关系特例

* 单向一对一关系
* 双向一对一关系

实线尖箭头

一个类中的成员变量用到另一个类，至少已经构成关联关系

#### 2.1.4 聚合关系 关联关系特例

空心菱形箭头的实线

使用set方法注入

可以分离独立存在，电脑和鼠标，键盘的关系

#### 2.1.5 组合关系 关联关系特例

全局对象new出来

不可一分离，不能缺少 人和头的关系

实心菱形箭头的实线

### 2.2 小结

关联和泛化是依赖特例，组合聚合是关联特例

## 3. 设计模式

* 创建型模式
    - 单例模式
    - 抽象工厂模式
    - 原型模式
    - 建造者模式
    - 工厂模式
* 结构型模式
    - 适配器模式
    - 桥接模式
    - 装饰模式
    - 组合模式
    - 外观模式
    - 享元模式
    - 代理模式
* 行为型模式
    - 模板方法模式
    - 命令模式
    - 访问者模式
    - 迭代器模式
    - 观察者模式
    - 中介者模式
    - 备忘录模式
    - 解释器模式
    - 状态模式
    - 策略模式
    - 责任链模式

### 3.1 单例模式

#### 3.1.1 饿汉式

* 静态常量
    - 会造成内存浪费

```java
class Singleton {

    // 1. 构造器私有化
    private Singleton() {

    }

    // 2.本类内部创建对象实例
    private final static Singleton instance = new Singleton();


    public static Singleton getInstance() {
        return instance;
    }
}
```  

* 静态代码块

#### 3.1.2 懒汉式

* 线程不安全
* 线程安全，同步方法
* 线程安全，同步代码块

#### 3.1.3 双重检查

* 懒加载
* 线程安全

```java
class Singleton {

    // 1. 构造器私有化
    private Singleton() {

    }

    /**
     * volatile 防止指令重排
     */
    private static volatile Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### 3.1.4 静态内部类

1. 静态类在调用的时候被加载 懒加载
2. 线程安全

```java
class Singleton {

    // 1. 构造器私有化
    private Singleton() {

    }

    // 静态内部类 外部类被装载的时候 内部类不会被装载
    private static class SingletonInstance {
        private final static Singleton INSTANCE = new Singleton();
    }


    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```

#### 3.1.5 枚举

* 线程安全
* 防止反序列化创建新对象
* 推荐使用

```java
enum Singleton {
    INSTANCE;

    public void sayOk() {
        System.out.println("ok");
    }
}
```

### 3.1.6 反序列化实现单例

[Java设计模式之使用反序列化的方式实现单例模式](https://www.cnblogs.com/dongyaotou/p/13584685.html)

要加readResolve方法

```java_method
    Object readResolve() throws ObjectStreamException{
        return instance;
    }
```

### 3.2 工厂模式

#### 3.2.1 简单工厂模式

#### 3.2.2 工厂方法模式

#### 3.2.3 抽象工厂模式

### 3.3 原型模式

#### 3.3.1 浅拷贝

默认clone，实现Cloneable接口

#### 3.3.2 深拷贝实现

* clone
* 反序列化
  ``

### 3.4 建造者模式

* Product 产品角色 ：一个具体的产品对象
* Builder 抽象建造者：创建一个Product对象的各个部件的抽象类/接口
* ConcreteBuilder 具体建造者：实现接口构建和装配各个部件
* Director 指挥者 ：构建一个使用builder接口的对象，隔离客户与对象的生产过程，负责控制产品对象的生产过程

#### 3.4.1 对比工厂

工厂不关注创建过程只关注产品由什么工厂组装，建造者模式注重创建过程，流程，核心为产品属性管理，可以改进产品创建过程

### 3.5 适配器模式

* 类适配器 有继承关系 继承
* 对象适配器 用关联关系替代继承关系 使用合成复用原则替换继承 持有
* 接口适配器 缺省适配器模式，不需要实现接口所有方法，使用抽象类实现部分方法 实现

#### 3.5.1 案例

spring mvc dispatchServlet使用适配器模式 匹配对应handler 执行对应方法，controller提前注册

### 3.5 桥接模式

* 将实现与抽象放在两个不同层次的类中，使两个层次可以独立改变
* 结构型设计模式
* 基于类的最小设计原则，通过使用封装，聚合，继承等行为让不同的类承担职责

### 3.6 装饰者模式

星巴克咖啡调料问题，装饰者进行不断套娃

### 3.7 组合模式

* 学校 学院 系是组合关系
* 又叫部分整体模式，树形结构展示

### 3.8 外观模式

影院设备管理

* 外观类，负责为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求
* 调用者，外观接口调用者
* 子系统集合，指模块或者子系统，处理外观对象指派的任务

### 3.9 享元模式

* 蝇量模式，运用共享技术支持大量细粒度的操作
* 池化技术场景

#### 3.9.1 java 使用

Integer使用享元模式 -128到127会被缓存

### 3.10 代理模式

* 静态代理 通过接口
* 动态代理 jdk代理 通过接口
* cglib代理 内存中动态创建 不需要接口 属于动态代理

#### 3.10.1 静态代理

* 优点 简单
* 缺点 代理对象和被代理对象需要实现相同接口，接口增加方法后，维护困难

#### 3.10.2 jdk动态代理

* 在内存中动态的创建对象

#### 3.10.3 cglib动态代理

* 不需要实现任何接口
* ASM字节码框架实现
* 代理类不能是final

### 3.11 模板方法模式

* 在一个抽象类中公开定义了执行他的方法的模板
* 可以定义钩子方法 影响模板方法逻辑

### 3.12 命令模式

* 动作的请求者和动作的执行者进行解耦
* Invoker是调用者
* Command是命令角色
* Receiver是接收者
* ConcreteCommand是调用接受者相应操作，实现execute

### 3.13 访问者模式

1. 意图：主要将数据结构与数据操作分离。
2. 主要解决：稳定的数据结构和易变的操作耦合问题。
3. 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。
4. 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。
5. 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。
6. 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。
7. 优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。
8. 缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。
9. 使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类

### 3.1.14 迭代器模式

### 3.1.15 观察者模式

### 3.1.16 中介者模式

### 3.1.17 备忘录模式

### 3.1.18 解释器模式

1. Context：环境角色，包含解释器之外的全局信息
2. AbstractExpression：抽象表达式，抽象语法树中所有节点共享
3. TerminalExpression:终结符表达式
4. NonTerminalExpression：非终结符表达式

spring spel

```java_method
public void spelTest(){
        SpelExpressionParser spelExpressionParser = new SpelExpressionParser();
        Expression expression = spelExpressionParser.parseExpression("10 * (2+1)* 1 + 66");
        int result = (int)expression.getValue();
        System.out.println(result);
    }
```

### 3.1.19 状态模式

* Context：环境角色，维护State实例
* State抽象状态角色，定义一个接口封装，与Context的一个特点接口相关行为
* ConcreteState 具体的状态角色

