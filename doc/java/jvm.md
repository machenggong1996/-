# jvm

* [JVM参数设置、分析](https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)

## 1. java虚拟机介绍

1. 执行java字节码
2. 一次编译到处运行
3. 自动内存管理垃圾回收

### 1.1 架构模型

1. 基于栈的
2. 基于寄存器的

基于栈的优点，跨平台性，指令集小，指令多，但是执行性能比寄存器差

javap -v class文件 可以看字节码

### 1.2 jvm生命周期

1. 虚拟机启动 启动通过引导类加载器 bootstrap class loader 创建初始类
2. 虚拟机执行 java程序执行的时候会有一个java虚拟机进程
3. 虚拟机退出 正常结束，异常，System.exit()

### 1.3 jvm发展历程

1. 1996 Sun Classic VM 只提供解释器
2. JDK1.2 Exact Memory VM 能知道内存中某个位置的数据类型，热点探测，编译器与解释器混合使用
3. HotSpot JDK1.3 jvm默认虚拟机 jdk8 引入元空间 之前叫方法区 
4. BEA公司 JRocket 针对服务端 
5. IBM J9
6. Oracle javaME CDC/CLDC
7. Azul VM 高性能 指定平台
8. Apache Harmony
9. Microsoft VM
10. TaoBao JVM 对intel cpu耦合
11. Dalvik VM 支持提前编译
12. Graal VM 跨语言全栈虚拟机 

#### 1.3.1 HotSpot热点探测技术

1. 通过计数器找到最具编译价值的代码，触发即时编译或者栈上替换
2. 通过编译器与解释器协同工作，在最优化程序响应时间和执行性能取得平衡

## 2. 内存结构概述

![avatar](pics/jvm内存结构模型.png)

### 2.1 类加载过程

#### 2.1.1 类加载器

ClassLoader

#### 2.1.2 类加载过程

##### 1. 加载

1. 通过一个类的全限定名，获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区各种数据的这个类的访问入口

加载class文件的方式

1. 本地系统获取
2. 网络获取
3. zip压缩包，jar包，war包
4. 运行时计算生成 动态代理
5. 其他文件生成 JSP
6. 数据库
7. 加密文件，防止反编译

##### 2. 链接

###### 2.1 验证

确保class文件安全性，不会导致虚拟机崩溃

###### 2.2 准备

* 为类变量分配内存，并且设置该类变量的默认初始值，即0值
* 这里不包含用final修饰的static，因为final在编译时就会分配了，准备阶段会显式初始化
* 这里不会包含实例变量分配的初始化，类变量会分配在方法区中，实例变量会随着对象一起分配到java堆中

###### 2.3 解析

* 将常量池内的 符号引用 转换为 直接引用的过程，
* 实际就是 把引用的类的符号转换为实际类的过程
* 方法 字段 类 的符号引用变为常量池地址引用

##### 3. 初始化

* clinit 给static修饰变量或者代码块赋值，赋值按照代码顺序来的
* 子类静态变量货者代码块执行晚于父类的执行

#### 2.1.3 类加载器分类

* jvm分类两类加载器，引导类类加载器，自定义类加载器
* 其他类加载器简介继承ClassLoader类
* 系统的核心类库由引导类加载器加载