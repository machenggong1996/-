# jvm

* [JVM参数设置、分析](https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)

## 1. java虚拟机介绍

1. 执行java字节码
2. 一次编译到处运行
3. 自动内存管理垃圾回收

### 1.1 架构模型

1. 基于栈的
2. 基于寄存器的

基于栈的优点，跨平台性，指令集小，指令多，但是执行性能比寄存器差

javap -v class文件 可以看字节码

### 1.2 jvm生命周期

1. 虚拟机启动 启动通过引导类加载器 bootstrap class loader 创建初始类
2. 虚拟机执行 java程序执行的时候会有一个java虚拟机进程
3. 虚拟机退出 正常结束，异常，System.exit()

### 1.3 jvm发展历程

1. 1996 Sun Classic VM 只提供解释器
2. JDK1.2 Exact Memory VM 能知道内存中某个位置的数据类型，热点探测，编译器与解释器混合使用
3. HotSpot JDK1.3 jvm默认虚拟机 jdk8 引入元空间 之前叫方法区 
4. BEA公司 JRocket 针对服务端 
5. IBM J9
6. Oracle javaME CDC/CLDC
7. Azul VM 高性能 指定平台
8. Apache Harmony
9. Microsoft VM
10. TaoBao JVM 对intel cpu耦合
11. Dalvik VM 支持提前编译
12. Graal VM 跨语言全栈虚拟机 

#### 1.3.1 HotSpot热点探测技术

1. 通过计数器找到最具编译价值的代码，触发即时编译或者栈上替换
2. 通过编译器与解释器协同工作，在最优化程序响应时间和执行性能取得平衡

## 2. 内存结构概述

![avatar](pics/jvm内存结构模型.png)

### 2.1 类加载过程

#### 2.1.1 类加载器

ClassLoader

#### 2.1.2 类加载过程

##### 1. 加载

1. 通过一个类的全限定名，获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区各种数据的这个类的访问入口

加载class文件的方式

1. 本地系统获取
2. 网络获取
3. zip压缩包，jar包，war包
4. 运行时计算生成 动态代理
5. 其他文件生成 JSP
6. 数据库
7. 加密文件，防止反编译

##### 2. 链接

###### 2.1 验证

确保class文件安全性，不会导致虚拟机崩溃

###### 2.2 准备

* 为类变量分配内存，并且设置该类变量的默认初始值，即0值
* 这里不包含用final修饰的static，因为final在编译时就会分配了，准备阶段会显式初始化
* 这里不会包含实例变量分配的初始化，类变量会分配在方法区中，实例变量会随着对象一起分配到java堆中

###### 2.3 解析

* 将常量池内的 符号引用 转换为 直接引用的过程，
* 实际就是 把引用的类的符号转换为实际类的过程
* 方法 字段 类 的符号引用变为常量池地址引用

##### 3. 初始化

* clinit 给static修饰变量或者代码块赋值，赋值按照代码顺序来的
* 子类静态变量货者代码块执行晚于父类的执行

#### 2.1.3 类加载器分类

* jvm分类两类加载器，引导类类加载器，自定义类加载器
* 其他类加载器简介继承ClassLoader类
* 系统的核心类库由引导类加载器加载

### 2.2 双亲委派机制

1. 如果一个类收到类加载请求，它并不会自己先去加载，而是把这个请求交给其父类加载
2. 如果类加载器还存在父类加载器，继续向上委托
3. 如果父类完成加载，就成功返回，如果无法完成加载任务就交给子类加载器加载

优点：避免类重复加载，保护java核心api防止被篡改

#### 2.2.1 沙箱安全机制

不允许自定义的类或者包名与java核心api重复或者有主函数

#### 2.2.3 两个class对象相等的条件

1. 类的完整类名必须一致，包括包名，同一class文件
2. 加载这个类的classloader必须相同

#### 2.2.4 类的主动使用和被动使用

1. 主动使用 
2. 被动使用

## 3. 运行时数据区

![avatar](pics/jvm运行时数据区.png)

* 95%垃圾回收在堆区，5%在方法区
* RumTime对象是单例的

### 3.1 线程

* 在hotspot中每个线程与操作系统的本地线程一一对应，java线程执行终止后，本地线程也会回收
* 一旦线程本地初始化成功，就会调用java线程中的run()方法
* 守护线程，普通线程

### 3.2 程序计数器，（PC寄存器）

* PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令
* 没有垃圾回收
* 不会发生OOM