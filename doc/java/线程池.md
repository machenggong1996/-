# 线程池

[ThreadPoolExecutor的addWorker方法](https://blog.csdn.net/u011637069/article/details/79593114)

## 线程池源码

### FutureTask 配合 Callable

callable实现

### submit和execute区别

1. submit有返回值 execute没有返回值
2. 

### ThreadPoolExecutor关系

java.util.concurrent.Executor 第一层执行接口execute
java.util.concurrent.ExecutorService 第二层提交接口 submit接口
java.util.concurrent.AbstractExecutorService 第三层 执行接口和提交接口整合
java.util.concurrent.ThreadPoolExecutor 具体实现

### ThreadPoolExecutor参数

1. int corePoolSize, 核心线程数
2. int maximumPoolSize, 最大线程数
3. long keepAliveTime, 存活时间
4. TimeUnit unit, 时间单位
5. BlockingQueue<Runnable> workQueue, 工作队列
6. ThreadFactory threadFactory, 线程工厂
7. RejectedExecutionHandler handler, 饱和策略

### ThreadPoolExecutor#execute 方法解析

execute->addWorker->new Worker(firstTask)->

Worker实现AQS和Runnable 实现run方法执行runWorker方法，task.run()执行真正的业务逻辑，
processWorkerExit方法退出->继续调用addWorker方法，达到线程池复用

### execute执行四种情况

![avatar](pics/execute四种情况.png)

1. 线程数量小于核心线程数，将work放入核心数量里面
2. 线程数量大于核心线程数，将work放入workQueue
3. 不满足前两种，创建非核心线程执行，失败之后执行拒绝策略

### 四种拒绝策略

1. CallerRunsPolicy 由当前线程调用
2. AbortPolicy，默认策略，抛异常
3. DiscardPolicy 什么都不做
4. DiscardOldestPolicy 移出队列
