# 操作系统

## 内容

### 分类
shell(外壳) linux windows Android的界面

kernel(内核)
 * cpu调度器
 * 物理内存管理
 * 虚拟内存管理
 * 文件系统管理
 * 中断处理与设备驱动

kernel 4个特征
 * 并发 一段时间内多个程序执行 （并行 一个时间点内多个程序执行 多cpu）
 * 共享 同时共享 互斥共享
 * 虚拟 CPU虚拟化为进程 磁盘虚拟化为文件 内存虚拟化为地址空间
 * 异步 程序不是执行到底 而是走走停停 但是最终结果一致

### 启动

CPU 内存 IO 通过总线连接

disk 存放OS

bios 基本IO除处理系统 检查外设 

bootloader 加载OS从硬盘上 在主引导第一个扇区占512字节

BIOS-Bootloader-OS

### 中断 异常 系统调用

系统调用(来源应用程序) 应用程序主动向操作系统发出服务请求 处理时间 同步或异步

异常(来源不良反应应用程序) 非法指令或者其他坏的处理 处理时间 同步

中断(来源于外设) 来自不同的硬件的计时器和网络中断 处理时间 异步

内核信任 应用程序不信任

### 计算机体系结构/内存分层体系

1. cpu
2. 内存
3. 设备I/O

cpu有L1缓存 L2缓存  主存为RAM 磁盘ROM可作为虚拟内存

#### 操作系统中管理内存的不同方法

* 程序重定位
* 分段
* 分页
* 虚拟内存
* 按需分页虚拟内存

#### 地址生成&地址空间

1. 地址空间

* 物理地址空间

* 逻辑地址空间 运行程序看到的地址空间 比较简单 是一维的

操作系统完成逻辑地址与物理地址的映射关系

#### 连续内存分配

1. 内存碎片问题

* 外部碎片 在分配单元间的未使用内存
* 内部碎片 在分配单元中的未使用内存

2. 分区的动态分配

* 第一次适配
* 最优适配
* 最差适配

3. 压缩式与交换式碎片整理

* 压缩式碎片管理

* 交换式碎片管理
  - 硬盘当做内存后备
  
### 非连续内存分配 分段

#### 为什么选择非连续内存分配

1. 连续内存分配缺点
 * 分配给一个程序的物理内存是连续的
 * 内存利用率低
 * 有外碎片和内碎片问题
2. 非连续内存分配优点
 * 一个程序的物理地址空间是非连续的
 * 更好的内存利用和管理
 * 运行共享代码与数据
 * 支持动态加载与动态链接
3. 非连续分配缺点
 * 如何建立虚拟地址与物理地址之间转换
  - 软件方案
  - 硬件方案
    - 分页
    - 分段
4. 分段 二维地址空间
 * 程序分段的地址空间
 * 分段寻址方案
  - 硬件寻址
  - cpu逻辑地址注册到段表
  - 段表存储base起始地址 limit限制大小
  - MMU内存管理单元找到物理地址
5. 分页 一维地址空间
 * 划分物理内存到固定大小的帧 大小是2的幂
 * 划分逻辑地址空间至相同大小的页 大小是2的幂
 * 建立方案 转换逻辑地址为物理地址 page to frame
  - 页表
  - MMU/TLB
6. 页表
 * 

### 虚拟内存

主存不够用，借助硬盘容量

#### 自动交换技术

发生在程序内部

将暂时不能运行的程序送到外存，从而获得空闲内存空间

换入从硬盘倒到内存/换出从内存倒到硬盘操作

处理器开销大

#### 手动覆盖技术

发生在程序之间

按照程序逻辑结构将程序划分为若干功能相对独立的程序模块，那些不会同时同时执行的的模块共享一块内存区域，按照时间先后来执行

缺点：增加开发负担，时间换空间

#### 虚拟存储技术

##### 程序局部性原理

1. 时间局部性

2. 空间局部性

##### 基本特征

* 大的用户空间
* 部分交换
* 不连续性

##### 虚拟页式内存管理

1. 请求调页
2. 页面置换
 * 最优页置换算法
 * 先进先出置换算法 链表链首主流时间最长 被替换出去
 * 最近最久未被使用算法LRU
 * 时钟页面置换算法
 * 二次机会法
 * 最不常用法
 
Belady现象：在采取FIFO算法时，页面增多，中断次数增多
LRU不会出现Belady现象 LRU采用栈算法 栈算法不会出现Belady现象

##### 全局页面置换算法

1. 工作集
2. 常驻集

##### 工作集页置换算法

缺页率=缺页次数/内存访问次数

影响因素

* 页面置换算法
* 分配给内存的物理页数
* 页面本身大小
* 程序的编写方法

##### 抖动问题

进程增加导致大量缺页，数据不断换进换出 导致抖动

##### 页表表项

1. 驻留位
2. 保护位
3. 修改位
4. 访问位
 
### 进程

#### 进程定义

一个具有独立功能的程序在一个数据集合上动态执行的过程

#### 进程的组成

* 程序代码
* 程序处理的数据
* 程序技术器的值，指示下一条执行的指令
* 一组通用的寄存器中的值
* 一组系统资源

#### 进程与程序的关系

* 程序是产生进程的基础
* 程序每次运行构成不同的进程
* 进程是程序功能的体现
* 通过多次执行一个程序可以对应多个进程，通过调用关系一个进程可以包括多个程序

#### 进程与程序区别

* 进程是动态的，程序是动态的，进程有程序的执行分核心态和用户态
* 进程是暂时的，程序是永久的
* 进程包括程序，数据和进程控制块
* 进程是一个过程

#### 进程特点

* 动态性：动态创建，结束进程
* 并发性：进程可以被独立调度并占用处理机运行
* 独立性：不同进程之间工作不相互影响
* 制约性：因访问共享数据/资源或进程间同步而产生制约

#### 进程控制结构 PCB进程控制块

PCB包括

* 进程标识信息 进程产生者标识父进程，用户标识
* 处理机状态信息保存区
 - 用户可见寄存器
 - 控制和状态寄存器
 - 栈指针
* 进程控制信息
 - 调度和状态信息
 - 进程间通信信息
 - 存储管理信息
 - 进程所用资源
 - 有关数据结构连接信息

PCB组织方式

* 链表方式组织

#### 进程状态

##### 进程生命周期管理

1. 进程创建
2. 进程就绪
3. 进程运行
4. 进程阻塞
5. 进程唤醒
6. 进程结束

##### 进程状态变化模型

运行状态
就绪：获取除CPU之外一切资源
等待

进程挂起：进程没有占用内存空间

* 阻塞挂起状态：进程在外存等待某件事出现
* 就绪挂起状态：进程在外存但只要进入内存，即可运行

状态队列管理不同进程 就绪队列 阻塞队列

#### 进程通信

进程之间的信息交换,进程是分配系统资源的单位,各进程拥有独立的地址空间,一个进程不能直接访问另一个进程的地址空间

#### 共享存储

进程间访问共享空间是互斥的

##### 基于数据结构共享

##### 基于存储区共享
  
#### 消息传递

格式化消息传递

消息头和消息体

##### 直接通信方式

消息直接挂载到接收进程的消息缓冲队列

##### 间接通信方式

消息要先发送到中间实体(信箱)中,也称为信箱通信方式

#### 管道通信

内存中开辟的固定大小缓冲区,半双工通信,同一时间段只能单向传输。如果要实现双向通信则需要设置两个管道

各进程互斥访问管道

数据以字符流的形式写入管道，写满阻塞，管道变空，读取阻塞

没有写满不允许读

读的进程只能有一个

#### 线程管理

更小的能独立运行的基本单位

1. 进程当中的一条执行流程

##### 线程优点

* 一个进程可以同时存在多个进程
* 各个线程可以并发执行
* 各个线程之间可以共享地址空间和文件等资源

##### 缺点

* 一个线程崩溃，会导致其所属进程的所有线程崩溃

##### 进程与线程比较

* 进程是资源分配基本单位，线程是CPU调度单位
* 进程拥有一个完整的资源平台，线程只独享必不可少的资源寄存器和栈
* 线程同样拥有运行，就绪，准备状态

##### 线程实现

1. 用户线程 用户线程库
2. 内核线程 操作系统
3. 轻量级进程

##### 上下文切换

上下文切换寄存器（PC,SP,...）CPU状态... 

##### 创建进程

##### 等待和终止进程

